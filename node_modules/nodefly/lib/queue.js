var EventEmitter = require('events').EventEmitter;
var proxy = require('./proxy');

var stats = require('./node-measured').createCollection();

var nf;


function checkNextTick(obj, args) {
	var t = Date.now();

	function beforeTick (obj, args, extra, context) {
		var now = Date.now();
		var dt = now - t;
		
		if (dt > nf.blockThreshold) {			
			stats.aggregator('wait').mark(dt);
			stats.meter('rate').mark();
		}

		if (context && context.graph) {
			context.graph.ticks++;
		}
	}
	
	proxy.callback(args, -1, beforeTick);	
}


function checkQueue(obj, args){
	var t = Date.now();
	proxy.callback(args, -1, function(obj, args, extra) {
		// dummy next tick to measure queue blockage
		process.nextTick(function(){ return; });
	});
}



function sample(code,time) {
	stats.aggregator(code).mark(time.ms);
}

var qStats;
var update;

function startEmitingQueueStats(){
	setInterval(function emitQueueStats(){
		stats._ts = nf.millis();
		qStats = stats.toJSON();
		
		if (!qStats || !qStats.rate || !qStats.wait) {
			update = [ 0, 0 ];
		}
		else {
			update = [qStats.rate.mean, qStats.wait.avg];
		}
		nf.metric(null, 'queue', update);
		//nf.emit('queue', update);
		
		stats.reset();
	}, 10*1000);
}


exports.init = function() {
	nf = global.nodefly;

	proxy.before(process, [ 'nextTick' ], checkNextTick);
	//proxy.before(EventEmitter.prototype, [ 'addListener', 'on', 'once' ], checkQueue);
	proxy.before(global, [ 'setTimeout', 'setInterval' ], checkQueue);
	
	startEmitingQueueStats();
};
